# MIP-20260226: MOON Search Performance and Auto-Embedding

## Status

- Status: Draft (updated)
- Owner: Brian (Master)
- Executor: Lilac (Assistant)
- Workspace: `~/.lilac_metaflora`

## 1. Problem

MOON currently handles snapshotting, projection, and collection sync (`moon-index` -> `qmd collection add/update`), but it does not own embedding lifecycle.

Impact:

1. Manual operations: agents must run embed commands separately.
2. Backlog risk: semantic retrieval quality lags until embeddings are refreshed.
3. Operational risk: large backlog embedding can become a long CPU-intensive task.

Observed at draft time (February 26, 2026):

1. Backlog estimate was 396 documents and about 73,191 chunks.
2. This number is environment-dependent and expected to drift over time.

## 2. Goals and Non-Goals

Goals:

1. Add a safe MOON-native embedding command (`moon moon-embed`).
2. Support bounded work per run (sprint mode) when QMD supports bounded embedding.
3. Integrate embedding with watcher lifecycle without blocking archive/distill flow.
4. Add deterministic progress, lock semantics, and audit/warning output.

Non-goals:

1. Replacing QMD internals or SQLite schema.
2. Reworking recall ranking logic.
3. Hard-coupling to undocumented QMD private tables.

## 3. Current Codebase Constraints

From current repo state:

1. `src/moon/qmd.rs` supports `collection add/update`, `search`, and `update`; no embed wrapper exists.
2. `src/cli.rs` has no `MoonEmbed` command.
3. `src/moon/watcher.rs` already has cooldown and deterministic stage sequencing.
4. `src/moon/state.rs` has no embed progress/checkpoint fields.
5. `docs/failure_policy.md` and warning codes do not include embedding failures yet.

## 4. Proposal

### 4.1 New CLI Command

Add:

```bash
moon moon-embed [--name <collection>] [--max-docs <N>] [--dry-run] [--allow-unbounded] [--watcher-trigger]
```

Flags:

1. `--name <collection>`: default `history`.
2. `--max-docs <N>`: upper bound for selected projection docs in one run. Default `25`.
3. `--dry-run`: report candidates and planned action only.
4. `--allow-unbounded`: allow full unbounded backend embed when bounded mode is unavailable.
5. `--watcher-trigger`: internal call path marker for watcher-origin runs (for reporting/audit).

`--max-docs` semantics:

1. Unit is projection documents (`archives/mlib/*.md`), not chunks.
2. Deterministic ordering: oldest modified file first, tie-break lexical path.

### 4.2 Capability-Negotiated Execution

Because QMD batching capability may differ by version, `moon-embed` uses capability negotiation:

1. Probe QMD embed capability once per run.
2. If QMD supports bounded embed natively, execute bounded run with `--max-docs`.
3. If QMD does not support bounded embed:
   - Manual invocation fails safe with actionable warning unless `--allow-unbounded` is set.
   - Watcher path skips auto-embed and emits a degraded-mode warning.

This avoids pretending sprint mode exists when backend support is absent.

Capability probe contract:

1. Run `qmd embed --help` once and capture `stdout/stderr/exit`.
2. If command is missing or help cannot be read, capability is `missing`.
3. If help indicates bounded controls (target surface: `--max-docs`), capability is `bounded`.
4. Otherwise capability is `unbounded-only`.
5. Report capability in command details as `embed.capability=<bounded|unbounded-only|missing>`.

### 4.3 Concurrency and Locking

Use single-flight lock file:

1. Path: `$MOON_LOGS_DIR/moon-embed.lock`.
2. If active lock exists, return `ok=true` with `embed.skipped=locked` for watcher mode.
3. Manual mode can return `ok=false` with actionable issue unless `--watcher-trigger` is set.
4. Stale lock handling: lock is stale when PID is absent or lock age is above stale TTL; stale lock is replaced.

Lock payload contract:

1. Lock payload is JSON with fields: `pid`, `started_at_epoch_secs`, `mode`, `collection`.
2. Stale TTL default is `21600` seconds (6 hours).
3. If lock file is malformed, treat as stale and replace, and emit audit detail.

### 4.4 Watcher Integration

Hook embedding after projection/index stage and before any optional retention cleanup.

Trigger rules:

1. Only when archive/index stage succeeded in this cycle.
2. Respect embed cooldown and idle gates.
3. Never block compaction/distill if embed fails.
4. On failure, emit warning + audit; continue cycle in degraded mode.
5. Per-cycle embed runtime is bounded by `embed.max_cycle_secs`; timeout is reported as `EMBED_FAILED` with `reason=timeout`.

### 4.5 Config Contract (`moon.toml`)

Add:

```toml
[embed]
mode = "manual"              # manual | idle
idle_secs = 600              # minimum idle before watcher auto-embed
cooldown_secs = 300          # minimum seconds between embed attempts
max_docs_per_cycle = 25      # watcher run budget
min_pending_docs = 1         # watcher trigger threshold
max_cycle_secs = 90          # hard runtime budget for one watcher embed attempt
```

Default mode is `manual` for conservative rollout.

### 4.6 State Contract (`MOON_STATE_FILE`)

Extend state schema with embed bookkeeping:

1. Bump `schema_version` to `2`.
2. Add `last_embed_trigger_epoch_secs: Option<u64>`.
3. Add `embedded_projections: BTreeMap<String, u64>` where key is projection path and value is last embedded epoch.
4. Migration rule: missing embed fields are treated as empty/default.
5. Update rule: write `embedded_projections[path]=now` only for documents confirmed embedded in this run.
6. On partial failure, keep successful document updates and leave failed documents pending.
7. Garbage-collect `embedded_projections` entries for projection files that no longer exist.

Purpose:

1. Deterministic pending detection without scanning QMD private internals.
2. Crash-safe resume and duplicate-work reduction.

Pending detection and selection contract:

1. A projection is pending when either:
   - it has no `embedded_projections` entry, or
   - file modified time is newer than saved embed epoch.
2. Selection order is deterministic: `(modified_time ASC, path ASC)`.
3. `--max-docs` and watcher budget both apply to selected pending projection docs (not chunks).

### 4.7 Degraded-Mode Decision Matrix

| Caller | Capability | `--allow-unbounded` | Behavior | `ok` | Warning |
|---|---|---|---|---|---|
| manual | bounded | false/true | run bounded embed | true on success | none |
| manual | unbounded-only | false | fail safe | false | `EMBED_CAPABILITY_MISSING` |
| manual | unbounded-only | true | run unbounded embed | true on success | audit degraded mode |
| watcher | bounded | n/a | run bounded embed | true on success | none |
| watcher | unbounded-only | n/a | skip embed | true | `EMBED_CAPABILITY_MISSING` |
| manual/watcher | missing | false/true | manual fails, watcher skips | manual false / watcher true | `EMBED_CAPABILITY_MISSING` |

## 5. Failure Policy Integration

Add warning codes:

1. `EMBED_FAILED`
2. `EMBED_LOCKED`
3. `EMBED_CAPABILITY_MISSING`
4. `EMBED_STATUS_FAILED`

Stage/action examples:

1. `stage=embed action=run-embed`
2. `stage=embed action=acquire-lock`
3. `stage=embed action=check-capability`
4. `stage=embed action=resolve-pending`
5. `stage=embed action=run-bounded`
6. `stage=embed action=run-unbounded`

Policy:

1. Watcher mode: emit warning, continue cycle.
2. Manual mode: surface failure in command report (`ok=false`) unless explicitly degraded.
3. Always append audit detail.

## 6. Report Contract (`CommandReport` details)

`moon moon-embed` should emit:

1. `collection=<name>`
2. `embed.mode=<manual|watcher>`
3. `embed.capability=<bounded|unbounded-only|missing>`
4. `embed.requested_max_docs=<N>`
5. `embed.selected_docs=<N>`
6. `embed.embedded_docs=<N>`
7. `embed.pending_before=<N>`
8. `embed.pending_after=<N>`
9. `embed.elapsed_ms=<N>`
10. `state_file=<path>`
11. `embed.degraded=<true|false>`
12. `embed.skip_reason=<none|locked|capability-missing|cooldown|idle-not-met>`

This supports agent automation and easy triage.

## 7. Rollout Plan

Phase 1:

1. Add `moon-embed` command + QMD capability probe + locking + command report.
2. Manual-only operation (`[embed].mode = "manual"` default).

Phase 2:

1. Add watcher trigger path under `embed.mode = "idle"`.
2. Add cooldown/idle gates and degraded failure behavior.

Phase 3:

1. Tune defaults based on field metrics.
2. Optional adaptive budget strategy (increase/decrease `max_docs_per_cycle` by recent duration).

## 8. Testing Plan

Unit tests:

1. Selection ordering determinism.
2. Lock acquisition and stale lock replacement.
3. Capability negotiation behavior.
4. State merge/update idempotency.
5. Pending detection via mtime and state epoch comparison.
6. State migration from schema v1 file to v2 default embed fields.
7. Partial success state update behavior.

Integration tests:

1. `moon-index` -> `moon-embed` happy path.
2. Capability matrix behavior for manual and watcher caller modes.
3. Watcher run with embed enabled and disabled.
4. QMD failure path emits warning and audit while watcher continues.
5. Lock overlap: manual invocation during watcher embed (and inverse).
6. Timeout path respects `embed.max_cycle_secs`.
7. JSON output contract for automation use (`--json`).

Regression checks:

1. Distill and compaction behavior unchanged when embed is disabled.
2. No duplicate embed worker when daemon and manual invocation overlap.
3. Watcher loop latency does not regress significantly when embed mode is `manual`.

## 9. Success Metrics

Primary:

1. Decrease median age of unembedded projection docs.
2. Decrease pending projection count over time.

Safety:

1. Zero watcher crashes caused by embed stage.
2. No increase in compaction/distill failure rate after embed integration.

## 10. Open Questions

1. What exact QMD embed capability surface (`--max-docs` or equivalent) is guaranteed across supported QMD versions?
2. Should pending detection rely only on MOON state, or additionally consume a stable `qmd status` signal when available?
